####################################################
# LSrouter.py
# Name:
# HUID:
#####################################################
import sys
from collections import defaultdict
from router import Router
from packet import Packet
from json import dumps, loads
import yaml

class LSrouter(Router):
    """Link state routing protocol implementation.

    Add your own class fields and initialization code (e.g. to create forwarding table
    data structures). See the `Router` base class for docstrings of the methods to
    override.
    """

    def __init__(self, addr, heartbeat_time):
        Router.__init__(self, addr)  # Initialize base class - DO NOT REMOVE
        self.heartbeat_time = heartbeat_time
        self.last_time = 0
        # TODO
        #   add your own class fields and initialization code here
        self.graph = {} 
        self.seq_num = {}
        self.graph[addr] = {}
        self.seq_num[addr] = 0
        self.table = {}
        self.portdict = {}

    def handle_packet(self, port, packet):
        """Process incoming packet."""
        # TODO
        if packet.is_traceroute:
            # Hint: this is a normal data packet
            # If the forwarding table contains packet.dst_addr
            #   send packet based on forwarding table, e.g., self.send(port, packet)
            addr = packet.dst_addr
            if addr in self.table:
                while self.table[addr] != self.addr and addr != self.addr:
                    addr = self.table[addr]
                if addr in self.graph[self.addr]:
                    # đưa gói tin ra 1 cổng của router đang xét 
                    self.send(self.graph[self.addr][addr]["port"], packet)  #router này kết nối với addr của packet ở cổng mấy thì đưa gói tin ra cổng đó. 
        else:
            # Hint: this is a routing packet generated by your routing protocol
            # If the sequence number is higher and the received link state is different
            #   update the local copy of the link state
            #   update the forwarding table
            #   broadcast the packet to other neighbors
            # nếu nhận được routin packet: gồm content, sequence number của router KHÁC 
            ifupdate = False
            content = yaml.safe_load(packet.content)
            #content lưu nội dung của gói định tuyến 
            addrs = content["add"] if content["add"] else content["reduce"] 
            #addrs["src"] = địa chỉ của router phát gói tin đi 
            if addrs is not None and addrs["src"] not in self.seq_num:
                self.seq_num[addrs["src"]] = 0
            #seq_num: sequence number mới nhất (số phiên bản) mà router hiện tại đã biết hoặc xử lý từ các router khác trong mạng.
            if addrs is None or content["seq_num"] <= self.seq_num[addrs["src"]]: #cập nhật định kỳ hoặc gói tin cũ 
            #if content["seq_num"] <= self.seq_num[addrs["src"]]: 
                self.dijkstra()
                return
            
            self.seq_num[addrs["src"]] = content["seq_num"]

            if addrs["src"] not in self.graph:
                self.graph[addrs["src"]] = {}

            if content["add"] or content["reduce"]: 
                self.graph[addrs["src"]] = content["info"] # thêm vào đồ thị cái mới và các liên kết của nó 
            else:
                ifupdate = True 
                
            if ifupdate: # ko có sự thay đổi liên kết 
                self.dijkstra()
            else:
                for neighbor, info in self.graph[self.addr].items():
                    p = Packet(Packet.ROUTING, self.addr, neighbor, dumps(content))
                    self.send(info["port"], p) 

    def handle_new_link(self, port, endpoint, cost):
        """Handle new link."""
        # TODO
        #   update local data structures and forwarding table
        #   broadcast the new link state of this router to all neighbors
        self.graph[self.addr][endpoint] = {"port": port, "cost":cost}
        self.portdict[port] = endpoint
        self.seq_num[self.addr] += 1
        content = {
        "info": self.graph[self.addr],
        "add": {"src": self.addr, "tgt": endpoint},
        "reduce": None,
        "seq_num": self.seq_num[self.addr]
        }
        content = dumps(content)
        # lan tin cho các router hàng xóm 
        for neighbor, info in self.graph[self.addr].items():
            p = Packet(Packet.ROUTING, self.addr, neighbor, content)
            self.send(info["port"], p)


    def handle_remove_link(self, port):
        """Handle removed link."""
        # TODO
        #   update local data structures and forwarding table
        #   broadcast the new link state of this router to all neighbors
        endpoint = self.portdict.pop(port)
        self.graph[self.addr].pop(endpoint)
        self.seq_num[self.addr] += 1
        content = {
        "info": self.graph[self.addr],
        "add": None,
        "reduce": {"src": self.addr, "tgt": endpoint},
        "seq_num": self.seq_num[self.addr]
        }
        content = dumps(content)
        for neighbor, info in self.graph[self.addr].items():
            p = Packet(Packet.ROUTING, self.addr, neighbor, content)
            self.send(info["port"], p)


    def handle_time(self, time_ms):
        """Handle current time."""
        if time_ms - self.last_time >= self.heartbeat_time: # heartbeat_time: chu kỳ gửi gói tin định kỳ 
            self.last_time = time_ms
            # TODO

            #   broadcast the link state of this router to all neighbors
            content = {
            "info": self.graph[self.addr],
            "add": None,
            "reduce": None,
            }

            content = dumps(content)
            for neighbor, info in self.graph[self.addr].items():
                p = Packet(Packet.ROUTING, self.addr, neighbor, content)
                self.send(info["port"], p)
    

    def graph_with_clients(self):
        G = {}
        for src_addr, info in self.graph.items():
            #src_addr. info: các láng giềng của nó và cost 
            G[src_addr] = info # tạo dictiinary 
            for tgt_addr, info_d in info.items():
                if tgt_addr not in self.graph:
                    if tgt_addr not in G:
                        G[tgt_addr] = {} #nếu đích chưa có trong graph và G 
                    G[tgt_addr][src_addr] = info_d #dict chưa có trong graph, là ngoại vi 
        return G


    def dijkstra(self):
        self.table = {} #bảng định tuyến 
        N = set() #các node 
        D = {} #min từ  self.adddr đến mỗi node 
        for src, info in self.graph.items():
            N.add(src)
            for des, info_d in info.items():
                N.add(des)

        for addr in N:
            if addr != self.addr:
                #vô cùng nếu ko phải hàng xóm của self 
                D[addr] = float("inf") if addr not in self.graph[self.addr] else self.graph[self.addr][addr]["cost"]
            else:
                D[addr] = 0
        G = self.graph_with_clients()

        while(len(N) != 0):
            addr = min(N, key=lambda x: D[x])
            N.remove(addr)
            for neighbor, info in G[addr].items():
                D[neighbor] = min(D[neighbor], D[addr] + info["cost"])
                if D[addr] + info["cost"] <= D[neighbor]:
                    self.table[neighbor] = addr


    def __repr__(self):
        """Representation for debugging in the network visualizer."""
        # TODO
        #   NOTE This method is for your own convenience and will not be graded
        return f"LSrouter(addr={self.addr})"
